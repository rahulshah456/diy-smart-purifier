esphome:
  name: dotpwm_auto
  friendly_name: DIY Air Purifier Automatic
  on_boot:
    priority: -100
    then:
      - delay: 2s
      - script.execute: apply_mode

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
api:
ota:

wifi:
  ssid: "Archer C20"
  password: "ghanta@786"

web_server:
  port: 80

esp32_ble_server:

# ---------------- PERSISTENT STATE ----------------
globals:
  - id: current_mode
    type: int
    restore_value: yes
    initial_value: '3'   # 0=Quiet,1=Normal,2=Max,3=Auto

  - id: last_manual_speed
    type: int
    restore_value: yes
    initial_value: '60'

# ---------------- MODE BUTTON (PHYSICAL) ----------------
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO18
      mode: INPUT_PULLUP
      inverted: true
    name: "Mode Button"
    on_press:
      then:
        - lambda: |-
            id(current_mode) = (id(current_mode) + 1) % 4;
        - script.execute: apply_mode

# ---------------- FAN PWM ----------------
output:
  - platform: ledc
    pin: GPIO25
    frequency: 25000 Hz
    id: fan_pwm

fan:
  - platform: speed
    id: purifier_fan
    name: "Purifier Fan"
    output: fan_pwm
    speed_count: 100
    restore_mode: RESTORE_DEFAULT_OFF

# ---------------- FAN RPM ----------------
sensor:
  - platform: pulse_counter
    pin:
      number: GPIO27
      mode:
        input: true
    id: fan_rpm
    name: "Fan RPM"
    unit_of_measurement: "RPM"
    update_interval: 2s
    accuracy_decimals: 0
    count_mode:
      rising_edge: INCREMENT
      falling_edge: DISABLE
    filters:
      - multiply: 0.5
      - exponential_moving_average:
          alpha: 0.4

# ---------------- PMS7003 ----------------
uart:
  rx_pin: GPIO16
  tx_pin: GPIO17
  baud_rate: 9600

sensor:
  - platform: pmsx003
    type: PMS7003
    pm_2_5:
      id: pm25
      name: "PM2.5"

  - platform: template
    id: aqi
    name: "AQI"
    accuracy_decimals: 0
    lambda: |-
      float pm = id(pm25).state;
      if (pm <= 12.0) return pm * 4.17;
      if (pm <= 35.4) return 50 + (pm - 12.1) * 2.1;
      if (pm <= 55.4) return 100 + (pm - 35.5) * 2.46;
      if (pm <= 150.4) return 150 + (pm - 55.5) * 0.52;
      if (pm <= 250.4) return 200 + (pm - 150.5) * 0.39;
      return 300;

  - platform: uptime
    id: esp_uptime_sec
    name: "ESP Uptime (s)"
    update_interval: 10s

  - platform: template
    name: "Fan Speed (%)"
    accuracy_decimals: 0
    lambda: |-
      return id(last_manual_speed);
    update_interval: 2s

# ---------------- UPTIME TEXT ----------------
text_sensor:
  - platform: template
    id: esp_uptime_text
    name: "ESP Uptime"
    update_interval: 10s
    lambda: |-
      int t = (int) id(esp_uptime_sec).state;
      char buf[16];
      snprintf(buf, sizeof(buf), "%02d:%02d:%02d",
               t/3600, (t%3600)/60, t%60);
      return std::string(buf);

# ---------------- AUTO MODE LOGIC ----------------
script:
  - id: apply_mode
    then:
      - lambda: |-
          if (id(current_mode) == 0) {        // Quiet
            id(last_manual_speed) = 25;
            id(purifier_fan).turn_on().set_speed(25);
          }
          else if (id(current_mode) == 1) {   // Normal
            id(last_manual_speed) = 60;
            id(purifier_fan).turn_on().set_speed(60);
          }
          else if (id(current_mode) == 2) {   // Max
            id(last_manual_speed) = 100;
            id(purifier_fan).turn_on().set_speed(100);
          }
          else {                              // Auto
            float pm = id(pm25).state;
            int speed = 25;
            if (pm < 25) speed = 25;
            else if (pm < 50) speed = 40;
            else if (pm < 100) speed = 60;
            else if (pm < 150) speed = 80;
            else speed = 100;
            id(purifier_fan).turn_on().set_speed(speed);
          }

interval:
  - interval: 30s
    then:
      - if:
          condition:
            lambda: 'return id(current_mode) == 3;'
          then:
            - script.execute: apply_mode

# ---------------- WEB UI BUTTONS ----------------
button:
  - platform: template
    name: "Quiet Mode"
    on_press:
      - lambda: 'id(current_mode)=0;'
      - script.execute: apply_mode

  - platform: template
    name: "Normal Mode"
    on_press:
      - lambda: 'id(current_mode)=1;'
      - script.execute: apply_mode

  - platform: template
    name: "Max Mode"
    on_press:
      - lambda: 'id(current_mode)=2;'
      - script.execute: apply_mode

  - platform: template
    name: "Auto Mode"
    on_press:
      - lambda: 'id(current_mode)=3;'
      - script.execute: apply_mode

# ---------------- OLED DISPLAY ----------------
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: true

font:
  - file: "arial.ttf"
    id: font_small
    size: 10

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    lambda: |-
      const char* mode =
        id(current_mode) == 0 ? "Quiet" :
        id(current_mode) == 1 ? "Normal" :
        id(current_mode) == 2 ? "Max" : "Auto";

      it.printf(0, 0, id(font_small), "DIY PURIFIER AUTO");
      it.printf(0, 12, id(font_small),
                "IP: %s", WiFi.localIP().toString().c_str());
      it.printf(0, 24, id(font_small), "Mode: %s", mode);
      it.printf(0, 36, id(font_small),
                "PM2.5: %.1f", id(pm25).state);
      it.printf(0, 48, id(font_small),
                "AQI: %.0f", id(aqi).state);
